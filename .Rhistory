Dir_alpha[a]
Dir_alpha[a] = D_sum * pi[a]
Dir_alpha[a]
rgamma(n=nRyrs,Dir_alpha[a],1)
g[,a] = rgamma(n=nRyrs,Dir_alpha[a],1)
g[,a]
t=1
sum(g[t,])
sum(g[t,1:A])
g[,a]
View(g)
# needs a re run ========
for (a in 1:A) {
Dir_alpha[a] = D_sum * pi[a]
g[,a] = rgamma(n=nRyrs,Dir_alpha[a],1)
for (t in 1:nRyrs) {
p[t,a] = g[t,a]/sum(g[t,1:A])
}
}
View(p)
for (a in 1:A) {
Dir_alpha[a] = D_sum * pi[a]
g[,a] = rgamma(n=nRyrs,Dir_alpha[a],1)
}
View(g)
for (a in 1:A) {
for (t in 1:nRyrs) {
p[t,a] = g[t,a]/sum(g[t,1:A])
}
}
View(p)
# Init ===================
nByrs=105 #number of samples per population
nRyrs = 108
pops = 1 #seq(1,3,1) #population pointer vector
population<- c(rep(1,nByrs)) #population pointer vector
K = 1 # number of stocks
A = 4 # age classes
#n.pop <-length(unique(population)) #number of population
#year <- rep(seq(1,
Ps = 0.5 # proportion of females - assumption, need to lit check
fs = as.matrix(c(1800, 2000, 2200, 2440)) # fecundity - Gilk-Baumer 2009 estimate for Kusko Chum is: 2440. I added extra numbers temporarily just so that younger fish reproduce less, but will have to look up data for this more...
#Bev Holt parameters ===================
# p for alpha, and c for carrying capacity
basal_p_1 = 0.2#
basal_p_2 = 0.4#,
#hist(log(runif(100,10e3, 10e7)))
# log(runif(1,10e3, 10e7))
c_1 <- as.matrix(nrow = 1, ncol =1,exp(18.4)) # exp(rnorm(1,20,5)))#rnorm(1,1e12, 1e2))
c_2 <- as.matrix(nrow = 1, ncol =1,exp(15))# (rnorm(1,as.numeric(max(juv$abund)),5))) # ,5))) #rnorm(1,1e, 1e2))
# Covariate data ===================
cov1 <-  matrix(nrow = nByrs, ncol =1, rnorm(nByrs*1, 0, 2))  #Cov 1 data
cov2 <- matrix(nrow = nByrs, ncol =1, rnorm(nByrs*1, 0, 2))  #Cov2 data
sigma_coef1 <- as.matrix(nrow = 1, ncol =1, 0.1)
sigma_coef2 <- as.matrix(nrow = 1, ncol =1, 0.1)
mu_coef1 <- 0.1 #rnorm(0, 10)
mu_coef2 <- -0.2 #rnorm(0, 10)
theta1 <- rnorm(1,mu_coef1,sigma_coef1[1,1])
theta2 <- rnorm(1,mu_coef2,sigma_coef2[1,1])
pi = c(NA)
Dir_alpha = c(NA)
p = matrix(nrow=nRyrs,ncol=A,NA)
g = matrix(nrow=nRyrs,ncol=A,NA)
prob = c(0.1148158, # rbeta(1,1,1),
0.2157721, # rbeta(1,1,1),
0.5999373, # rbeta(1,1,1),
0.609483)  # rbeta(1,1,1))
D_scale = 0.4411873 # rbeta(1,1,1)
pi[1] = prob[1]# because its fixed, prob is currently data
pi[2] = prob[2] * (1 - pi[1])
pi[3] = prob[3] * (1 - pi[1] - pi[2])
pi[4] = 1 - pi[1] - pi[2] - pi[3]
D_sum = 1/D_scale^2
for (a in 1:A) {
Dir_alpha[a] = D_sum * pi[a]
g[,a] = rgamma(n=nRyrs,Dir_alpha[a],1)
}
for (a in 1:A) {
for (t in 1:nRyrs) {
p[t,a] = g[t,a]/sum(g[t,1:A])
}
}
View(p)
View(g)
# Simulate populations  ===================
#error is fixed in model right now so fix it here.
process_error_j <- matrix(nrow=K,ncol=1,rep(1.1, times =K))  #matrix(nrow=nByrs,ncol=1,rep(1, times =nByrs )) #rnorm(nByrs*1,1,0.2))
process_error_sp <- matrix(nrow=K,ncol=1,rep(2, times =K)) #matrix(nrow=nRyrs,ncol=1,rep(2, times =nRyrs )) #rnorm(nByrs*1,5, 1))
process_error_r <- matrix(nrow=K,ncol=1,rep(3, times =K))  #matrix(nrow=nRyrs,ncol=1,rep(3, times =nRyrs )) #rnorm(nByrs*1,5, 1))
# make pop model matricies and starting values =========
kappa_j =  matrix(nrow=nByrs,ncol=K,NA)
kappa_marine =  matrix(nrow=nByrs,ncol=K,NA)
N_j =  matrix(nrow=nByrs,ncol=K,NA)
N_e_sum = matrix(nrow=nByrs,ncol=K,NA)
N_recruit = matrix(nrow=nByrs,ncol=K,NA)
N_e = array(data = NA, dim = c(nRyrs, K,A))
N_returning = array(data = NA, dim = c(nRyrs, K,A))
N_sp = array(data = NA, dim = c(nRyrs, K,A))
# starting values
mean.spawn <- exp(rep(c(rnorm(1,14,2), rnorm(1,14,2), rnorm(1,14,2), rnorm(1,14,2)), times=A))
N_sp[1:A,1,] <- mean.spawn
N_e[1,1,] = exp(rnorm(A,20,2))
N_j[1,1] = exp(rnorm(1,20,2)) #mean(juv$abund)# rnorm(K,20,10)
N_recruit[1,1] = mean(harvest_escapement$Harvest)
N_returning[1:A,1,]  = rep(exp(rnorm(1,14,2))*prob, times =A)
N_e_sum[1,1] = exp(rnorm(1,35,2))
N_recruit[1,1] = exp(rnowm(14,2)) #mean(harvest_escapement$Harvest)
N_recruit[1,1] = exp(rnorm(14,2)) #mean(harvest_escapement$Harvest)
N_recruit[1,1] = exp(rnorm(1,14,2)) #mean(harvest_escapement$Harvest)
N_returning[1:A,1,]  = rep(exp(rnorm(1,14,2))*prob, times =A)
N_e_sum[1,1] = exp(rnorm(1,35,2))
p_1 =  matrix(nrow=nByrs,ncol=K,NA)
p_2 =  matrix(nrow=nByrs,ncol=K,NA)
catch_q = exp(rnorm(1,0,0.5))
# Use covariates - calc productivity in bev holt transition function =====
# lines below need to be edited if I use more stocks!! theta and cov 1 should be multipled and summed, can get away with just multiplying here because there is only 1 stock and 1 covar
p_1[,1]  = 1 / 1+ exp(-basal_p_1 - (theta1*cov1[,1])) # covariate impacts survival, impact is measured through theta
p_2[,1]  = 1 / 1+ exp(-basal_p_2  - (theta2 *cov2[,1]))
# simulate H_b ==========
# this is the harvest, going to do a percent of the population instead of whole numbers, struggling with this part a little bit
H_b  <-  array(data = rdirichlet(n=nRyrs, alpha=rep(10,A)), dim = c(nRyrs, K, A)) # higher value for alpha is a more tighlty clustered distribution
# o_run <- array(data = as.matrix(yukon_summer[,2:5]), dim = c(nRyrs, K,A))
# #o_run <- as.matrix(yukon_summer[,2:5]) # observed run size by age class
# o_run_comp <- array(data = as.matrix(summer_age_comp[,2:5]), dim = c(nRyrs, K,A))
# o_run_comp_mat <- as.matrix(summer_age_comp[,2:5]) # proportional age comp by year
# ess_age_comp <- rep(200, times = nRyrs)
# k=1
# t=2
# Run population model ============
for(k in 1:K){  # loop for each population
for (t in 2:nByrs){
#kappa_j[t,k] = 1.8/(1+((1.8*N_e_sum[t-1,k])/c_1[k,1])) # Eq 4.1  - Bev holt transition estimating survival from Egg to Juvenile (plugs into Eq 4.4)
kappa_j[t,k] =  p_1[t,k]/ (1+((p_1[t,k]*N_e_sum[t-1,k])/c_1[k,1])) # Eq 4.1  - Bev holt transition estimating survival from Egg to Juvenile (plugs into Eq 4.4)
N_j[t,k] = kappa_j[t,k]*N_e_sum[t-1,k] # Eq 4.4  generated estimate for the amount of fish each year and stock that survive to a juvenile stage
kappa_marine[t,k] =  p_2[t,k]/ (1 + ((p_2[t,k]*N_j[t,k])/c_2[k,1])) # Eq 4.1   - Bev holt transition estimating survival from juvenile to spawner (plugs into Eq 4.4)
N_recruit[t,k] = kappa_marine[t,k]*N_j[t,k] # Eq 4.5 generated estiamte for the amount of fish each year and stock that survive to a spawning stage
#add in age for stage where I am tracking age class....
# switch to calendar years using t+A-a
for (a in 1:A) {
N_returning[t+A-a,k,a] = (catch_q[k]*N_recruit[t,k])*p[t+A-a,a] # currys indexing here: N_ta[t,a] = R[t+A-a] * p[t+A-a,a];
N_sp[t+A-a,k,a] = N_returning[t+A-a,k,a]*(1-H_b[t+A-a,k,a]) # harvest percent, 1-H_b are the ones that stay
N_e[t+A-a,k,a] = fs[a,1]*Ps*N_sp[t+A-a,k,a] # Eq 4.3 generated estimate for the amount of eggs produced that year for that stock.
}
# transition back to brood years - plug in ages manually
N_e_sum[t,k] = (N_e[t+A-1,k,1]+N_e[t+A-2,k,2]+N_e[t+A-3,k,3]+N_e[t+A-4,k,4])
}
}
q = array(data = NA, dim = c(nRyrs, K, A))
for(k in 1:K){
for (t in 1:nRyrs) {
for(a in 1:A){
q[t,k,a] = N_returning[t,k,a]/sum(N_returning[t,k,1:A]);
}
}
}
# simulate from pop =============
N_j[1,] = mean(N_j[2:nByrs,1]) #mean(N_j[2:n,1:n.pop]) # just so i don't get yelled at about NA's later down the road
N_j_sim <-  matrix(nrow=nByrs,ncol=K,NA)
N_sp_sim_s <-  array(data = NA, dim = c(nRyrs, K))
N_sp_sim <-  array(data = NA, dim = c(nRyrs, K ))
N_returning_sim_s <-  array(data = NA, dim = c(nRyrs, K))
N_returning_sim <-  array(data = NA, dim = c(nRyrs, K ))
# add up age classes before simulating  ============
# because actual data inputs will not have age class
N_sp[is.na(N_sp)] <- 0
N_sp_sim[1:nRyrs,1]<- N_sp[1:nRyrs,1,1] + N_sp[1:nRyrs,1,2] + N_sp[1:nRyrs,1,3] +N_sp[1:nRyrs,1,4]
N_returning[is.na(N_returning)] <- 0
N_returning_sim[1:nRyrs,1]<- N_returning[1:nRyrs,1,1] + N_returning[1:nRyrs,1,2] + N_returning[1:nRyrs,1,3] +N_returning[1:nRyrs,1,4]
for (k in 1:K) {
N_j_sim[,k] = rlnorm(nByrs, log(N_j[2:nByrs,k]), process_error_j[1,1])
#for (a in 1:A) {
N_returning_sim_s[,k] = rlnorm(nRyrs, log(N_returning_sim[2:nRyrs,k]), process_error_r[1,1])
N_sp_sim_s[,k] = rlnorm(nRyrs, log(N_sp_sim[2:nRyrs,k]), process_error_sp[1,1])
# }
}
#sigma_j_obs<-
c(sd(log(N_j_sim)[6:nByrs,1]))
#sigma_r_obs<-
c(sd(log(N_returning_sim_s)[6:nRyrs,1]))
#sigma_sp_obs<-
c(sd(log(N_sp_sim_s)[6:nRyrs,1]))
## assign data list ==========
data_list <- list(nByrs=nByrs,
nRyrs=nRyrs,
A=A,
K=K,
Ps=Ps,
fs=fs,
data_stage_j = N_j_sim,
data_stage_return = N_returning_sim_s,
data_stage_sp = N_sp_sim_s,
sigma_y_j=process_error_j,
sigma_y_r=process_error_r,
sigma_y_sp=process_error_sp,
kappa_marine_start = matrix(0.4, nrow = 1, ncol = 1), #kappa_marine_start,
kappa_j_start = matrix(0.2,nrow = 1, ncol = 1),
cov1 = cov1,
cov2 = cov2,
ncovars1 = 1,
ncovars2 = 1,
sigma_coef1 = sigma_coef1,
sigma_coef2=sigma_coef2,
basal_p_1=basal_p_1,
basal_p_2=basal_p_2,
H_b=H_b,
prob=prob,
c_1=c_1,
c_2=c_2)
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores)
warmups <- 2000
total_iterations <- 4000
max_treedepth <-  15
n_chains <- 1
n_cores <- 4
adapt_delta <- 0.95
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores)
init_fn <- function(chain_id=1) {
list(
"mu_prior_mean" = c(rnorm(1,40,1), rnorm(1,80,1)),
"mu_prior_sd" = abs(rnorm(n=K, mean=10, sd=1)),
"sigma_prior_mean" = abs(rnorm(n=K, mean=10, sd=1)),
"sigma_prior_sd" = abs(rnorm(n=K, mean=10, sd=1)),
"mu"= matrix(data=rep( c(rnorm(1,40,1), rnorm(1,80,1)) , n.years),
nrow=n.years, ncol=K, byrow=TRUE),
"theta"= rdirichlet(n=n.years, alpha=c(10,10))
)
}
init_fn
init_ll <- lapply(1:n.chains, function(id) init_fn(chain_id = id))
# Initial List of Lists for Multiple Chains
init_ll <- lapply(1:n_chains, function(id) init_fn(chain_id = id))
init_fn <- function(chain_id=1) {
list(
"c_1" = c(rnorm(1,40,1), rnorm(1,80,1)),
"c_2" = abs(rnorm(n=K, mean=10, sd=1)),
"theta1" = abs(rnorm(n=K, mean=10, sd=1)),
"theta2" = abs(rnorm(n=K, mean=10, sd=1)),
"g"= matrix(data=rep( c(rnorm(1,40,1), rnorm(1,80,1)) , n.years),
nrow=nByrs, ncol=K, byrow=TRUE),
"log_catch_q" =
"D_scale"= rdirichlet(n=nByrs, alpha=c(10,10))
)
}
# Initial List of Lists for Multiple Chains
init_ll <- lapply(1:n_chains, function(id) init_fn(chain_id = id))
init_fn <- function(chain_id=1) {
list(
"c_1" = c(rnorm(1,40,1), rnorm(1,80,1)),
"c_2" = abs(rnorm(n=K, mean=10, sd=1)),
"theta1" = abs(rnorm(n=K, mean=10, sd=1)),
"theta2" = abs(rnorm(n=K, mean=10, sd=1)),
"g"= matrix(data=rep( c(rnorm(1,40,1), rnorm(1,80,1)) , nByrs),
nrow=nByrs, ncol=K, byrow=TRUE),
"log_catch_q" =
"D_scale"= rdirichlet(n=nByrs, alpha=c(10,10))
)
}
# Initial List of Lists for Multiple Chains
init_ll <- lapply(1:n_chains, function(id) init_fn(chain_id = id))
init_fn <- function(chain_id=1) {
list(
"c_1" = c(rnorm(1,40,1), rnorm(1,80,1)),
"c_2" = abs(rnorm(n=K, mean=10, sd=1)),
"theta1" = abs(rnorm(n=K, mean=10, sd=1)),
"theta2" = abs(rnorm(n=K, mean=10, sd=1)),
"g"= matrix(data=rep( c(rnorm(1,40,1), rnorm(1,80,1)) , nByrs),
nrow=nByrs, ncol=K, byrow=TRUE),
"log_catch_q" =
"D_scale"= rdirichlet(n=nByrs, alpha=c(10,10))
)
}
# Initial List of Lists for Multiple Chains
init_ll <- lapply(1:n_chains, function(id) init_fn(chain_id = id))
# create initial values ===============
init_fn <- function(chain_id=1) {
list(
"mu_prior_mean" = c(rnorm(1,40,1), rnorm(1,80,1)),
"mu_prior_sd" = abs(rnorm(n=K, mean=10, sd=1)),
"sigma_prior_mean" = abs(rnorm(n=K, mean=10, sd=1)),
"sigma_prior_sd" = abs(rnorm(n=K, mean=10, sd=1)),
"mu"= matrix(data=rep( c(rnorm(1,40,1), rnorm(1,80,1)) , nByrs),
nrow=nByrs, ncol=K, byrow=TRUE),
"theta"= rdirichlet(n=nByrs, alpha=c(10,10))
)
}
# Initial List of Lists for Multiple Chains
init_ll <- lapply(1:n_chains, function(id) init_fn(chain_id = id))
init_ll
c(runif(n=K, 1e6, 1e8))
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores) #,
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_core)
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores)
init_fn <- function(chain_id=1) {
list(
"c_1" = c(runif(n=K, 1e6, 1e8)),
"c_2" = c(runif(n=K, 1e4, 1e6)),
"theta1" = c(rnorm(n=K, 0.1, 5)),
"theta2" = c(rnorm(n=K, -0.2, 10)),
# "g"= matrix(data=rep( c(rnorm(1,40,1), rnorm(1,80,1)) , nRyrs),
#              nrow=nByrs, ncol=A, byrow=TRUE),
"log_catch_q" = c(rnorm(n=K, 0, 0.05)),
"D_scale"= rbeta(1,1,1)
)
}
# Initial List of Lists for Multiple Chains
init_ll <- lapply(1:n_chains, function(id) init_fn(chain_id = id))
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores,
init=init_ll)
runif(n=K, 1e6, 1e8)
as.matrix(nrow = 1, ncol =1,runif(n=K, 1e6, 1e8))
init_fn <- function(chain_id=1) {
list(
"c_1" = as.matrix(nrow = 1, ncol =1,runif(n=K, 1e6, 1e8)),
"c_2" = as.matrix(nrow = 1, ncol =1,runif(n=K, 1e4, 1e6)),
"theta1" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, 0.1, 5)),
"theta2" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, -0.2,10)),
# "g"= matrix(data=rep( c(rnorm(1,40,1), rnorm(1,80,1)) , nRyrs),
#              nrow=nByrs, ncol=A, byrow=TRUE),
"log_catch_q" = c(rnorm(n=K, 0, 0.05)),
"D_scale"= rbeta(1,1,1)
)
}
# Initial List of Lists for Multiple Chains
init_ll <- lapply(1:n_chains, function(id) init_fn(chain_id = id))
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores,
init=init_ll)
init_fn <- function(chain_id=1) {
list(
"c_1" = runif(n=K, 1e6, 1e8), # as.matrix(nrow = 1, ncol =1,runif(n=K, 1e6, 1e8)),
"c_2" = as.matrix(nrow = 1, ncol =1,runif(n=K, 1e4, 1e6)),
"theta1" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, 0.1, 5)),
"theta2" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, -0.2,10)),
# "g"= matrix(data=rep( c(rnorm(1,40,1), rnorm(1,80,1)) , nRyrs),
#              nrow=nByrs, ncol=A, byrow=TRUE),
"log_catch_q" = c(rnorm(n=K, 0, 0.05)),
"D_scale"= rbeta(1,1,1)
)
}
# Initial List of Lists for Multiple Chains
init_ll <- lapply(1:n_chains, function(id) init_fn(chain_id = id))
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores,
init=init_ll)
init_fn <- function(chain_id=1) {
list(
"c_1" = c(runif(n=K, 1e6, 1e8)), # as.matrix(nrow = 1, ncol =1,runif(n=K, 1e6, 1e8)),
"c_2" = as.matrix(nrow = 1, ncol =1,runif(n=K, 1e4, 1e6)),
"theta1" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, 0.1, 5)),
"theta2" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, -0.2,10)),
# "g"= matrix(data=rep( c(rnorm(1,40,1), rnorm(1,80,1)) , nRyrs),
#              nrow=nByrs, ncol=A, byrow=TRUE),
"log_catch_q" = c(rnorm(n=K, 0, 0.05)),
"D_scale"= rbeta(1,1,1)
)
}
# Initial List of Lists for Multiple Chains
init_ll <- lapply(1:n_chains, function(id) init_fn(chain_id = id))
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores,
init=init_ll)
as.vector(runif(n=K, 1e6, 1e8))
init_fn <- function(chain_id=1) {
list(
"c_1" = as.vector(runif(n=K, 1e6, 1e8)), # as.matrix(nrow = 1, ncol =1,runif(n=K, 1e6, 1e8)),
"c_2" = as.matrix(nrow = 1, ncol =1,runif(n=K, 1e4, 1e6)),
"theta1" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, 0.1, 5)),
"theta2" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, -0.2,10)),
# "g"= matrix(data=rep( c(rnorm(1,40,1), rnorm(1,80,1)) , nRyrs),
#              nrow=nByrs, ncol=A, byrow=TRUE),
"log_catch_q" = c(rnorm(n=K, 0, 0.05)),
"D_scale"= rbeta(1,1,1)
)
}
# Initial List of Lists for Multiple Chains
init_ll <- lapply(1:n_chains, function(id) init_fn(chain_id = id))
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores,
init=init_ll)
init_fn <- function(chain_id=1) {
list(
"c_1" = as.matrix(nrow = 1, ncol =1,runif(n=K, 1e6, 1e8)),
"c_2" = as.matrix(nrow = 1, ncol =1,runif(n=K, 1e4, 1e6)),
"theta1" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, 0.1, 5)),
"theta2" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, -0.2,10)),
# "g"= matrix(data=rep( c(rnorm(1,40,1), rnorm(1,80,1)) , nRyrs),
#              nrow=nByrs, ncol=A, byrow=TRUE),
"log_catch_q" = c(rnorm(n=K, 0, 0.05)),
"D_scale"= rbeta(1,1,1)
)
}
# Initial List of Lists for Multiple Chains
init_ll <- lapply(1:n_chains, function(id) init_fn(chain_id = id))
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores,
init=init_ll)
init_fn <- function(chain_id=1) {
list(
"c_1" = as.matrix(nrow = 1, ncol =1,runif(n=K, 1e6, 1e8)),
"c_2" = as.matrix(nrow = 1, ncol =1,runif(n=K, 1e4, 1e6)),
"theta1" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, 0.1, 5)),
"theta2" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, -0.2,10)),
# "g"= matrix(data=rep( c(rnorm(1,40,1), rnorm(1,80,1)) , nRyrs),
#              nrow=nByrs, ncol=A, byrow=TRUE),
"log_catch_q" = as.matrix(nrow = 1, ncol =1,rnorm(n=K, 0, 0.05)),
"D_scale"= rbeta(1,1,1)
)
}
# Initial List of Lists for Multiple Chains
init_ll <- lapply(1:n_chains, function(id) init_fn(chain_id = id))
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores,
init=init_ll)
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores,
init=init_ll)
# call mod  ===========================
bh_fit <- stan(
file = here::here("scripts", "stan_mod_BH_DATA.stan"),
data = data_list,
chains = n_chains,
warmup = warmups,
iter = total_iterations,
cores = n_cores,
init=init_ll)
N_j_sim
N_returning_sim_s
N_sp_sim_s
